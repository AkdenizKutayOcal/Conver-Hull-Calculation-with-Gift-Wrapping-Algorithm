<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Convex Hull</title>
  <style>
    html, body, #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
    }
    
  </style>
  
  <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
  
  <link rel="stylesheet" href="https://js.arcgis.com/4.11/esri/css/main.css">
  <script src="https://js.arcgis.com/4.11/"></script>

  <script>  
    require([
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/FeatureLayer",
      "esri/layers/GraphicsLayer",
      "esri/Graphic",
      "esri/geometry/Point",
      
    ], function(Map, MapView,FeatureLayer,GraphicsLayer,Graphic,Point) {
        
        var map = new Map({
            basemap: "dark-gray-vector"
        }); 

        var view = new MapView({
            container: "viewDiv",
            map: map,
            center: [32.8,39.9],
            zoom: 2
        });
        const NUMBER_OF_POINTS = 25;
        window.leftMostIndex;
        var points = turf.randomPoint(NUMBER_OF_POINTS, {bbox: [26.960449,36.914764,43.615723,41.013066]});
        var pointLayer = new GraphicsLayer();
        var polygonLayer = new GraphicsLayer();
        var convexHullArray = [];
        var pointSymbol = {

            type: "simple-marker",
            size: 6,
            color: "white",  // orange
            outline: {
                color: [255, 255, 255], // white
                width: 1
            }
        };
        var pointArray = [];
        var polygonSymbol = {

            type: "simple-fill",
            style: "solid",
            color: [115, 76, 0, 255],
            outline: {
                color: [255, 255, 255], // white
                width: 1
            }
        };
        map.add(pointLayer);
        polygonLayer.opacity = 0.5;
       
        map.add(polygonLayer);
        
        addPoints(points);

        var btn_convexHull = document.createElement('button');
        btn_convexHull.title = "Calculate Convex Hull";
        btn_convexHull.innerHTML = "Calculate Convex Hull";
        
        btn_convexHull.addEventListener('click', () => {

            calculateConvexHull(points,convexHullArray);
            convertPoints(pointArray,convexHullArray);
            
            console.log("geldim");
            console.log(pointArray);
            
            var ringsArray = [];

            for(var k = 0; k<pointArray.length;k++){

              var coordinates = [pointArray[k].latitude,pointArray[k].longitude];
              ringsArray.push(coordinates);

            }
            var convexPolygon = {

              type:"polygon",
              rings: ringsArray
            };

            console.log(convexPolygon);
            console.log("geldim2");
            
            var convexGraphic = new Graphic({

              geometry: convexPolygon,
              symbol: polygonSymbol

            });

            console.log(convexGraphic);
            console.log("geldim3");

            polygonLayer.add(convexGraphic);

          }
        );

        view.ui.add(btn_convexHull,"top-left");        
        
      function convertPoints(pointArray,convexHullArray){
          console.log(convexHullArray[1]);
          for(var b =0;b<convexHullArray.length;b++){
           
            var point = {
              type: "point",
              latitude: convexHullArray[b].coordinates[0],
              longitude: convexHullArray[b].coordinates[1]
            }
            pointArray.push(point);
          }
        }

        function calculateConvexHull(points,finalArray){

          var leftMostPoint = findLeftMost(points);

          var p = leftMostIndex,q;  //p starts with leftMost index. P is the left most and q is the second point to compare

          do{

            finalArray.push(points.features[p].geometry);   //push leftMost

            q = (p+1)%NUMBER_OF_POINTS;

            for(var i = 0;i<NUMBER_OF_POINTS-1;i++){

              if(calculateOrientation(points.features[p].geometry.coordinates,points.features[i].geometry.coordinates,points.features[q].geometry.coordinates)===1){

                q = i;
              }
            }

            p = q;

          }while(p!= leftMostIndex); //continues until it reaches start point
          
        }

        //Calculates the orientation using cross product
        //0 --> colinear
        //1 --> clockwise
        //2 --> counter clockwise

        function calculateOrientation(pointA, pointB, pointC){

          var orientation = (pointB[1] - pointA[1]) * (pointC[0] - pointB[0]) - (pointB[0] - pointA[0]) * (pointC[1] - pointB[1]);

          if(orientation === 0){

            return 0;
          }
          else if(orientation>0){

            return 1;
          }
          else{
           
            return 2;
          }
        }
        function findLeftMost(points){
         
          var leftPoint = new Point();
          var min = points.features[0].geometry.coordinates[0];

          for(var i = 1;i<NUMBER_OF_POINTS;i++){

            if(points.features[i].geometry.coordinates[0]<min){
              
              min = points.features[i].geometry.coordinates[0];
              leftPoint.latitude = points.features[i].geometry.coordinates[0];
              leftPoint.longitude = points.features[i].geometry.coordinates[1];
              leftMostIndex = i;
            }
          }
          return leftPoint;
        }

        function addPoints(points){

            var esriPoints = [];
            var esriGraphics = [];

            points.features.forEach(element => {
                
                var esriPoint = {
                    type: "point",
                    longitude: element.geometry.coordinates[0],
                    latitude: element.geometry.coordinates[1]
                };

                esriPoints.push(esriPoint);
            });

            var i = 0;

            esriPoints.forEach(point =>{
                
                var esriGraphic = {

                    geometry: esriPoints[i++],
                    symbol: pointSymbol
                };

                esriGraphics.push(esriGraphic);
            });

            var j = 0;

            esriGraphics.forEach(graphic=>{

                pointLayer.add(esriGraphics[j++]);

            });
        }

        function esriGraphicToGeoJSON(data){

          data = data.toJSON();
          if(data.geometry.x){

            return {"type": "Point", "coordinates": [data.geometry.latitude,data.geometry.longitude]};
          }

          else if(data.geometry.paths){

            if(data.geometry.paths.length===1){
              return {"type": "LineString", "coordinates": data.geometry.paths[0]};
            }
            else{
              return {"type": "MultiLineString", "coordinates": data.geometry.paths}; 
            }
          }
          else if(data.geometry.rings){

            return {"type": "Polygon","coordinates": data.geometry.rings};
          }    
        }

        function GeoJSONtoEsriGraphic(data){

          if(data.geometry.type === "Point"){

            return{"type":"point","latitude":data.geometry.coordinates[0],"longitude":data.geometry.coordinates[1]};
          }
          else if(data.geometry.type === "Polyline"){

            
          }
          else if(data.geometry.type === "Polygon"){
            
            return {"type":"polygon","rings":data.geometry.coordinates};
          }
        }

    });
  </script>
</head>
<body>
  <div id="viewDiv"></div>
</body>
</html>